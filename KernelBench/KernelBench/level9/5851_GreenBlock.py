import torch
from torch import nn


def conv3d(in_channels, out_channels, kernel_size, bias, padding=1, stride=1):
    return nn.Conv3d(in_channels, out_channels, kernel_size, padding=
        padding, bias=bias, stride=stride)


class GreenBlock(nn.Module):
    """
    green_block(inp, filters, name=None)
    ------------------------------------
    Implementation of the special residual block used in the paper. The block
    consists of two (GroupNorm --> ReLu --> 3x3x3 non-strided Convolution)
    units, with a residual connection from the input `inp` to the output. Used
    internally in the model. Can be used independently as well.

    Parameters
    ----------
    `inp`: An keras.layers.layer instance, required
        The keras layer just preceding the green block.
    `filters`: integer, required
        No. of filters to use in the 3D convolutional block. The output
        layer of this green block will have this many no. of channels.
    `data_format`: string, optional
        The format of the input data. Must be either 'chanels_first' or
        'channels_last'. Defaults to `channels_first`, as used in the paper.
    `name`: string, optional
        The name to be given to this green block. Defaults to None, in which
        case, keras uses generated names for the involved layers. If a string
        is provided, the names of individual layers are generated by attaching
        a relevant prefix from [GroupNorm_, Res_, Conv3D_, Relu_, ], followed
        by _1 or _2.

    Returns
    -------
    `out`: A keras.layers.Layer instance
        The output of the green block. Has no. of channels equal to `filters`.
        The size of the rest of the dimensions remains same as in `inp`.
    """

    def __init__(self, input_channels, output_channels):
        super(GreenBlock, self).__init__()
        self.conv3d_1 = conv3d(input_channels, output_channels, padding=0,
            kernel_size=1, bias=True)
        self.gn1 = nn.GroupNorm(input_channels, input_channels)
        self.act_1 = nn.ReLU()
        self.conv3d_2 = conv3d(input_channels, output_channels, kernel_size
            =3, bias=True)
        self.gn2 = nn.GroupNorm(output_channels, output_channels)
        self.act_2 = nn.ReLU()
        self.conv3d_3 = conv3d(output_channels, output_channels,
            kernel_size=3, bias=True)

    def forward(self, x):
        inp_res = self.conv3d_1(x)
        x = self.gn1(x)
        x = self.act_1(x)
        x = self.conv3d_2(x)
        x = self.gn2(x)
        x = self.act_2(x)
        x = self.conv3d_3(x)
        out = inp_res + x
        return out


def get_inputs():
    return [torch.rand([4, 4, 4, 4])]


def get_init_inputs():
    return [[], {'input_channels': 4, 'output_channels': 4}]
