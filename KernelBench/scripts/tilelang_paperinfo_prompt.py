TILELANG_PAPER_PROMPT = """
TileLang is a Python-based domain-specific language that simplifies high-performance AI kernel development on GPUs by combining Pythonic syntax, dataflow-centric programming, and composability. The language decouples scheduling aspects—such as thread binding, memory layout, tensorization, and pipelining—from dataflow, encapsulating them as a set of customization annotations and primitives. This approach enables users to concentrate on the kernel's dataflow, leaving most optimizations to the compiler.

In TileLang, tiles are treated as first-class objects representing shaped portions of data owned by warps, thread blocks, or parallel units. The language provides explicit control over hardware memory allocation: T.alloc_shared() allocates memory in fast, on-chip storage corresponding to shared memory on NVIDIA GPUs; T.alloc_fragment() allocates accumulators in fragment memory, corresponding to register files; and T.alloc_local() provides thread-private storage for individual thread operations. These allocations are crucial for optimizing data reuse and minimizing latency.

TileLang offers a suite of tile operators that abstract common computational patterns. For instance, T.copy is a specialized memory copy operator that abstracts parallel data movement among registers, shared memory, and global memory. T.gemm automatically selects implementations (e.g., CUTLASS for NVIDIA GPUs) for high-performance matrix multiplication on different GPUs, supporting various memory access patterns. T.reduce provides flexible reduction mechanisms for aggregating data across dimensions, supporting operations like sum, min, max, and product. T.atomic offers atomic operations for safe updates to shared or global memory in parallel contexts, supporting add, min, and max operations.

For scheduling, TileLang includes primitives like T.Pipelined, which enables efficient pipelined execution overlapping computation and memory operations, and T.Parallel, which automates parallelization of loops by mapping iterations to threads. T.annotate_layout allows specification of memory layout optimizations, and T.use_swizzle improves L2 cache locality by enabling swizzled memory accesses.

The language also supports advanced memory layout and thread binding through its Layout abstraction, which describes how data is organized in memory. This includes composable layout transformations and fragment layouts that extend standard layouts to better utilize register files. Thread binding inference uses a hierarchical priority system to optimize performance .

Beyond its core allocation capabilities, it provides T.alloc_var() for allocating single-element variable buffers.

For buffer initialization, T.fill() and T.clear() are available, while T.c2d_im2col() facilitates convolution-specific data layout transformations. Reduction operations are supported through functions like T.reduce_max(), T.reduce_min(), T.reduce_sum(), T.reduce_abssum(), and T.reduce_absmax(), catering to various reduction patterns.

To ensure thread-safe memory updates, TileLang includes atomic operations such as T.atomic_add() and T.atomic_addx2(). For low-level GPU instructions, T.dp4a() performs 4-element dot products with accumulation on integer types, and T.ptx_ldmatrix() handles tensor core matrix loading operations.

Synchronization and memory barriers are managed using T.SyncThreadsPartialOp() for partial thread synchronization and T.FenceProxyAsyncOp() for asynchronous fence operations. Specifically for Hopper GPUs, TileLang provides TMA (Tensor Memory Accelerator) operations, including T.CreateTMADescriptorOp() for descriptor creation, T.TMALoadOp() and T.TMAStoreOp() for high-bandwidth memory operations, and T.MBarrierWaitParity() and T.MBarrierExpectTX() for memory barrier coordination.

Utility and control primitives encompass logical operations like T.any_of() and T.all_of() for collective boolean operations across threads. Data manipulation functions such as T.clamp(), T.reshape(), and T.view() support various tensor operations. For source integration, T.import_source() allows C++ source injection, and T.call_extern() enables external function calls. Thread and loop control are facilitated by T.vectorized() for explicit vectorization, T.serial() for serial loop execution, and T.get_thread_binding() for accessing thread indices.
"""